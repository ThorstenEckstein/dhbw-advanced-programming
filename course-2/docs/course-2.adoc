include::../../docs/asciidoc/settings.adoc[]

:toc:

== {course-2}

*Allgemeine Inhalte*

//tag::content[]
* [ ] Methoden überladen, überschreiben/übersteuern
* [ ] Collections API
* [ ] Assoziationen (Beziehungsart "Besitz" im Code, sh. auch Kurstag 1)
//end::content[]

*Fachlicher Kontext*

Mögliche Assoziationen/Relationen mit Kardinalitäten

----
 + Zug          1:n      Wagon
 + Zug          1:1      Lokomotive
 + Zug          n:m      Soll-Fahrplan
  (=> Zug 1:n Fahrt 1:n Soll-Fahrplan)

 + Zug          n:m      Strecke
 + Zug          1:n      Fahrt
 + Strecke      1:n      Fahrt
  (=> Zug 1:n Fahrt n:1 Strecke)

 + Fahrt        1:n      Reisende
 + Zug          1:2..3   Flügel
 + Streckennetz 1:n      Strecke
 + Strecke      n:m      Abschnitte
----

=== UPDATE

Das *Projekt* bzw. der "_lokale Workspace_", d.h. euer lokales Arbeitsverzeichnis, in dem alle Sourcen liegen, muss als allererstes zum Start in den Tag aktualisiert werden, d.h. ...

-> _"Update Project"_

Das geht am besten mithilfe der IDE im Menü oder über das GIT Icon:

image::images/git-pull.png[width="30%", align="center"]

Danach muss - im sich öffnenden Dialog - noch folgendes bestätigt werden: _merge incoming changes into the current branch_

image::images/git-accept-merge.png[width="50%", align="center"]

Der Vorgang sollte mit einer Erfolgsmeldung abschließen.


=== Recap

Was bisher geschah ...

====
include::../../course-1/docs/course-1.adoc[tags="content"]
====


=== Überladen & Überschreiben

//IMPORTANT: HIER FORTSETZEN ... SIEHE TEST!

[source,java,title="Beispiel Überladen von Methoden"]
----
include::{course-2-src}/basics/overload/PlatformDisplay.java[lines="5..16"]
----

[plantuml, "overrides", png, float="left"]
....
include::diagrams/override.puml[]
....

[source,java,title="Beispiel Übersteuern von Methoden"]
----
include::{course-2-src}/basics/override/Display.java[lines="2..5"]
----

{nl}
{nl}
{nl}

Die zugehörige Annotation im Code ist

 @Override

Sie sollte in jedem Fall genutzt werden, zudem wird sie auch von der IDE vorgeschlagen


=== Collections Framework

Siehe z.B. -> https://en.wikipedia.org/wiki/Java_collections_framework[Java Collections Framework auf Wikipedia]

*Die wichtigsten Auswahlkriterien*:

* Position von Elementen (_numerischer index_)
* Möglichkeit zur Ordnung von Elementen (z.B. _insertion order_)
* Möglichkeit von `null` Elementen oder Duplikaten (_Set vs. List_)
* Zugriff auf Elemente anhand eines Schlüssels (_List vs. Map_)

image::images/collections-api.png["Collections API",width="100%",align="center"]


==== Java Collections API Interfaces

Java collection interfaces are the foundation of the Java Collections Framework. All core collection interfaces are generic.
For example `public interface Collection<E>`. The <E> syntax is for Generics and when we declare Collection (_später mehr zum Thema `Generics`_)

. *Collection interface*.
This is the root of the collection hierarchy. A collection represents a group of objects known as its elements. Some basic operations are provided.

. *Iterator Interface*.
Iterator interface provides methods to iterate over the elements of the Collection. Iterators allow the caller to remove elements from the underlying collection during the iteration.

. *Set Interface*
Set is a collection that cannot contain duplicate elements.
The Java platform contains three general-purpose Set implementations: HashSet, TreeSet, and LinkedHashSet.

. *List Interface*
List is an ordered collection and can contain duplicate elements. You can access any element by its index.
List has a dynamic length. ArrayList and LinkedList are implementation classes of List interface.

. *Queue Interface*
Queue is a collection used to hold multiple elements prior to processing.
Besides basic Collection operations, a Queue provides additional insertion, extraction, and inspection operations.
Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner.

. *Dequeue Interface*
A linear collection that supports element insertion and removal at both ends. The name deque is short for "double-ended queue"

. *Map Interface*
Java Map is an object that maps keys to values. A map cannot contain duplicate keys, each key can map to at most one value.
The Java platform contains three general-purpose Map implementations: HashMap, TreeMap, and LinkedHashMap.

. *SortedSet Interface*
SortedSet is a Set that maintains its elements in ascending order. Sorted sets are used for naturally ordered sets.

. *SortedMap Interface*
A map that maintains its mappings in ascending key order. This is the Map analog of SortedSet.
Sorted maps are used for naturally ordered collections of key/value pairs.

==== Special Java Collections Classes

Java Collections framework comes with many implementation classes for the interfaces. Most common implementations are:

. `HashSet` Class
. `TreeSet` Class
. `ArrayList` Class
. `LinkedList` Class
. `HashMap` Class
. `TreeMap` Class


==== Synchronized Wrappers

The *synchronization* wrappers add automatic synchronization (thread-safety) to an arbitrary collection.
Each of the six core collection interfaces - Collection, Set, List, Map, SortedSet, and SortedMap - has one static factory method, which return a synchronized (thread-safe) collection backed up by the specified collection.


==== Unmodifiable Wrappers

*Unmodifiable* wrappers take away the ability to modify the collection by intercepting all the operations that would modify the collection
and throwing an UnsupportedOperationException.

Its main usage are;

- To make a collection immutable once it has been built
- To allow certain clients read-only access to data structures (keep a reference to the backing collection but hand out a reference to the wrapper)
- To avoid ConcurrentModificationException


=== Assoziation

==== One-to-One-Assoziation


==== One-to-Many-Assoziation

Ein Beispiel für eine Eins-zu-Viele Beziehung:

[plantuml, "one-to-many", png, align="center"]
....
include::diagrams/one-to-many-example.puml[]
....

Siehe Implementierungen für V1 und V2:

 de.dhbw.course2.basics.collections.n


==== Many-to-Many-Assoziation

Die folgenden zwei Varianten kommen am häufigsten vor:

[plantuml, "many-to-many", png, align="center"]
....
include::diagrams/many-to-many-example-2.puml[]
....

Implementierungsbeispiele:

 de.dhbw.course2.basics.collections.n
 de.dhbw.course2.basics.collections.nm

Mehr zu Datenbanken & SQL siehe -> `Kurstag 7`.


=== Übungen

Die *Übungen* sollen in Form von *Unit-Tests* in folgendem _Package_ implementiert werden:

[subs=normal]
 src/[red]#*test*#/java/de/dhbw/course2/exercises/ExerciseTests.java

Die *Testobjekte*, also die _echten_ Klassen, Interfaces oder anderer Sourcecode sollen getrennt, nämlich hier umgesetzt werden:

[subs=normal]
 src/[red]#*main*#/java/de/dhbw/course2/exercises


Übung 1::

Erstelle eine Klasse `News`, die eine Aussage als String enthalten können. Mache die News durch Nutzung der `equals()` Methode vergleichbar, sodass du prüfen kannst, ob 2 News (= 2 Instanzen der Klasse News) mit verschiedenen - vielleicht _ähnlichen_ Aussagen - inhaltlich gleich oder sogar identisch sind.

Übung 2::

Schreibe einen Test, in dem eine `SortedMap` benutzt wird, befülle diese mit mindestens 5 Einträgen, nutze dazu `String` sowohl für den Schlüssel (K) also auch für den Wert (V). Beschreibe die Haupt-Charakteristik den dieses Map-Typus und prüfen, ob die Haupteigenschaft gegeben ist.

Übung 3::

_Ein Experiment_: Erzeuge eine Klasse `Person` mit einem Attribut `name` und leite daraus ein Interface `Mensch` ab, und zwar - so oft wie möglich - mithilfe von

* Code-Generation,
* Auto-Completion oder
* Refactoring-Proposals

die von der IDE angeboten werden (IntelliJ).

Testfragen::
Im Modul `/exam` finden sich weitere kleine Übungen für die Inhalte des Kurses 2, und zwar in der dortigen Testklasse:

[subs=attributes]
 {course-2-exam}/ExamTest.java

