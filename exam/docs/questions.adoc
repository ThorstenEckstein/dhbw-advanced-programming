include::../../docs/asciidoc/settings.adoc[]


:sectnums!:
:show-answers:


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Welche drei _Phasen_ werden beim *Test-Driven-Development* durchlaufen?

----
A. red, green, refactor
B. given, when, then
C. arrange, act, assert
----

[blue]#*Antwort*#:

ifdef::show-answers[]
-> A
endif::[]


{nl}


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Welche der folgenden *Listentypen* wäre am passendsten zur Speicherung von Listenelementen geeignet, wenn ein Listenelement nicht mehr als einmal vorkommen darf, und auch der Wert `null` ebenfalls nicht eingefügt werden darf?

----
A. Collection
B. List
C. Set
D. Map
E. Vector
----

[blue]#*Antwort*#:

ifdef::show-answers[]
-> C
endif::[]


{nl}


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Welches sind gültige *Eigenschaften* der Klasse `TreeSet` aus dem _Collections_ Framework?

----
A. benutzt Schlüsselwerte zur Speicherung von Werten
B. bewahrt die "natürliche" Ordnung der eingefügten Elemente
C. gestattet das Hinzufügen eines `null` Elementes
D. erlaubt das Einfügen von Duplikaten
----

[blue]#*Antwort*#:

ifdef::show-answers[]
-> B, C
endif::[]


{nl}


// >>>>>>>>>>>>>>>>>>>>>>>>> PAGE BREAK <<<<<<<<<<<<<<<<<<<<<<<<<<<<
<<<


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Was bedeutet *Überladung* (von Methoden)?

----
A. Wenn eine Methode eine Methode der Elternklasse übersteuert
B. Wenn eine Methode mehr als 3 Argumente aufweist
C. Wenn mehrere Methoden gleichen Names existieren, aber mit
   unterschiedlichen Parametern bzw. Parameterlisten
----

[blue]#*Antwort*#:

ifdef::show-answers[]
-> C
endif::[]


{nl}


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Java kennt unterschiedliche sogenannte `Access Modifier`, die den *Zugriff* bzw. die *Sichtbarkeit* von Klassen, Datenattributen oder Methoden steuern. Nennen Sie diese und beschrieben Sie kurz deren Bedeutung!

[blue]#*Antwort*#:

ifdef::show-answers[]
 default   = package-private, nur von Klassen im aktuellen
             Paket verfügbar/sichtbar
 public    = von überall verfügbar/sichtbar
 protected = nur in erbenden Klassen verfügbar/sichtbar
 private   = nur innerhalb der eigenen Klasse verfügbar/sichtbar
endif::[]


{nl}
{nl}
{nl}
{nl}
{nl}
{nl}
{nl}
{nl}
{nl}
{nl}


// >>>>>>>>>>>>>>>>>>>>>>>>> PAGE BREAK <<<<<<<<<<<<<<<<<<<<<<<<<<<<
<<<


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Setzen Sie die erforderlichen *Schlüsselworte* im folgenden kleinen Klassenmodell ein!

[source, java]
----
public interface Observable {}
public interface Train __________ Observable {}
public abstract class AbstractTrain __________ Train {}
public class LongDistanceTrain __________ AbstractTrain {}
----

[blue]#*Antwort*#:

ifdef::show-answers[]
[source, java]
----
public interface Observable {}
public interface Train extends Observable {}
public abstract class AbstractTrain implements Train {}
public class LongDistanceTrain extends AbstractTrain {}
----
endif::[]


{nl}


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Was ist ein *Interface*? Beschreiben Sie die _Bedeutung_ und nennen sie mindestens 2 Beispiele für deren _Eigenschaften_.

[blue]#*Antwort*#:

{nl}
{nl}
{nl}
{nl}
{nl}
{nl}
{nl}
{nl}

ifdef::show-answers[]
*Bedeutung*:

* Ein Interface stellt einen "Implementierungsvertrag" bzw. eine "Programmierschnittstelle" dar
* Interfaces fördern die Änderbarkeit von Software, da konkrete Implementierungen hinter diesen ausgetauscht werden können, ohne dass die Nutzung des Interfaces geändert werden muss.

*Eigenschaften*:

* Ein Interface hat keine Konstruktoren
* Ein Interface kann nicht instanziiert werden
* Alle Methoden eines Interfaces sind `public` und `abstract`
* Interfaces können `default` Methoden beinhalten
endif::[]


{nl}


// >>>>>>>>>>>>>>>>>>>>>>>>> PAGE BREAK <<<<<<<<<<<<<<<<<<<<<<<<<<<<
<<<


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Der nachfolgende Unit-Test wird nicht funktionieren. Warum nicht?

[source, java]
----
package dhbw.exam;

public class Person {
  private String name;
  private String getName() { return this.name; }
  public void setName(String name) { this.name = name; }
}
----

[source, java]
----
package dhbw.tests;

public class PersonTests {
  @Test
  public void canGetName() {
    // given
    Person person = new Person();

    // when
    String name = person.getName();

    // then
    assertNotNull(name);
  }
}
----

[blue]#*Antwort*#:

{nl}
{nl}
{nl}

ifdef::show-answers[]
Die Methode `getName()` ist _private_. Im Unit-Test kann nicht auf sie zugegriffen werden.
endif::[]


{nl}


// >>>>>>>>>>>>>>>>>>>>>>>>> PAGE BREAK <<<<<<<<<<<<<<<<<<<<<<<<<<<<
<<<


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Was ist der Unterschied zwischen *impliziter* und *expliziter Umwandlung* von primitiven Datentypen? Nennen Sie je ein Beispiel.

[blue]#*Antwort*#:

{nl}
{nl}
{nl}
{nl}
{nl}

ifdef::show-answers[]
Implizit: Typumwandlung von einem kleineren in einen größeren Datentyp,
Beispiel: `int -> long`

Explizit: Typumwandlung von einem größeren in einen kleineren Datentyp, `long -> int` mithilfe von `casting`
endif::[]


{nl}


// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

Welche der drei Aussagen trifft bzgl. des Schlüsselwortes `static` zu?
(_der Code-Ausschnitt unten dient als Ansichtsbeispiel_)

----
A. Der Aufruf einer statischen Methode kann nur über eine Instanz der umgebenden Klasse erfolgen
B. Der Wert einer statischen Klassenvariable kann nicht geändert werden
C. Der Aufruf einer statischen Methode erfordert keine Instanz der umgebenden Klasse
----

[source, java]
----
public class DateConverter {
  public static String TIME_ZONE = "UTC";
  public static Date parse(String dateAsString) { ... }
}
----

[blue]#*Antwort*#:

ifdef::show-answers[]
-> C
endif::[]


{nl}


////
+------------------------------------------------------------------+
|                                                                  |
|                         FRAGEN ARCHIV                            |
|                                                                  |
+------------------------------------------------------------------+
////

////
// -----------------------------------------------------------------
:question-seq: {counter:question-seq}
====
[.big.red]#*Frage {question-seq}*#
====

to be done?

----
Options
----

[blue]#*Antwort*#:

ifdef::show-answers[]
 ...
endif::[]


{nl}


////